# Subgraph Schema: DEX AMM
# Version: 1.0.0

enum Network {
  AVALANCHE
  AURORA
  BSC
  CELO
  CRONOS
  ETHEREUM
  FANTOM
  HARMONY
  MOONBEAM
  MOONRIVER
  OPTIMISM
  POLYGON
  XDAI
}

enum ProtocolType {
  EXCHANGE
  LENDING
  YIELD
  BRIDGE
  GENERIC
  # Will add more
}

type Token @entity {
  id: ID!
  name: String!
  symbol: String!
  decimals: Int!
}

enum RewardTokenType {
  DEPOSIT
  BORROW
}

type RewardToken @entity {
  id: ID!
  name: String!
  symbol: String!
  decimals: Int!
  type: RewardTokenType!
}

#############################
##### Protocol Metadata #####
#############################

interface Protocol {
  id: ID!
  name: String!
  slug: String!
  schemaVersion: String!
  subgraphVersion: String!
  network: Network!
  type: ProtocolType!
  totalUniqueUsers: Int!
  totalValueLockedUSD: BigDecimal!
  usageMetrics: [UsageMetricsDailySnapshot!]! @derivedFrom(field: "protocol")
  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: "protocol")
}

###############################
##### Protocol Timeseries #####
###############################

type UsageMetricsDailySnapshot @entity {
  id: ID!
  protocol: DexAmmProtocol!
  activeUsers: Int!
  totalUniqueUsers: Int!
  dailyTransactionCount: Int!
  blockNumber: BigInt!
  timestamp: BigInt!
}

type FinancialsDailySnapshot @entity {
  id: ID!
  protocol: DexAmmProtocol!
  totalValueLockedUSD: BigDecimal!
  protocolTreasuryUSD: BigDecimal
  protocolControlledValueUSD: BigDecimal
  totalVolumeUSD: BigDecimal!
  supplySideRevenueUSD: BigDecimal!
  protocolSideRevenueUSD: BigDecimal!
  feesUSD: BigDecimal!
  blockNumber: BigInt!
  timestamp: BigInt!
}

###############################
##### Pool-Level Metadata #####
###############################

# A pool can be:
# - A liquidity pool in the case of a DEX AMM
# - A market in the case of a lending protocol
# - A vault in the case of a yield aggregator
# Generally protocols accept one or multiple tokens and mint tokens to the depositor to track ownership
# Some protocols reward DAO tokens or other incentivisation tokens to holders of LP tokens
# Some protocols don't mint any tokens to track ownership, in that case outputToken is null
# and inputToken balances are used to calculate returns
interface Pool {
  id: ID!
  protocol: DexAmmProtocol!
  inputTokens: [Token!]!
  outputToken: Token!
  rewardTokens: [RewardToken!]
  ##### Quantitative Data #####
  totalValueLockedUSD: BigDecimal!
  totalVolumeUSD: BigDecimal!
  inputTokenBalances: [BigInt!]!
  outputTokenSupply: BigInt!
  outputTokenPriceUSD: BigDecimal!
  rewardTokenEmissionsAmount: [BigInt!]
  rewardTokenEmissionsUSD: [BigDecimal!]
  createdTimestamp: BigInt!
  createdBlockNumber: BigInt!
  snapshots: [PoolDailySnapshot!]! @derivedFrom(field: "pool")
}

#################################
##### Pool-Level Timeseries #####
#################################

type PoolDailySnapshot @entity {
  id: ID!
  protocol: DexAmmProtocol!
  pool: LiquidityPool!
  totalValueLockedUSD: BigDecimal!
  totalVolumeUSD: BigDecimal!
  inputTokenBalances: [BigInt!]!
  outputTokenSupply: BigInt!
  outputTokenPriceUSD: BigDecimal!
  rewardTokenEmissionsAmount: [BigInt!]
  rewardTokenEmissionsUSD: [BigDecimal!]
  blockNumber: BigInt!
  timestamp: BigInt!
}

###############################################################################
################################# DEX AMM #####################################
###############################################################################

type DexAmmProtocol implements Protocol @entity {
  id: ID!
  name: String!
  slug: String!
  schemaVersion: String!
  subgraphVersion: String!
  network: Network!
  type: ProtocolType!
  totalUniqueUsers: Int!
  totalValueLockedUSD: BigDecimal!
  usageMetrics: [UsageMetricsDailySnapshot!]! @derivedFrom(field: "protocol")
  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: "protocol")
  ##### DexAmm-Specific #####
  pools: [Pool!]! @derivedFrom(field: "protocol")
}

enum LiquidityPoolFeeType {
  TRADING_FEE
  PROTOCOL_FEE
  TIERED_FEE
  DYNAMIC_FEE
}

type LiquidityPoolFee @entity {
  id: ID!
  feePercentage: BigDecimal!
  feeType: LiquidityPoolFeeType!
}

type LiquidityPool @entity {
  id: ID!
  protocol: DexAmmProtocol!
  inputTokens: [Token!]!
  outputToken: Token!
  rewardTokens: [RewardToken!]
  ##### Quantitative Data #####
  totalValueLockedUSD: BigDecimal!
  totalVolumeUSD: BigDecimal!
  inputTokenBalances: [BigInt!]!
  outputTokenSupply: BigInt!
  outputTokenPriceUSD: BigDecimal!
  rewardTokenEmissionsAmount: [BigInt!]
  rewardTokenEmissionsUSD: [BigDecimal!]
  createdTimestamp: BigInt!
  createdBlockNumber: BigInt!
  snapshots: [PoolDailySnapshot!]! @derivedFrom(field: "pool")
  ##### DexAmm-Specific #####
  name: String
  symbol: String
  fees: [LiquidityPoolFee!]!
  deposits: [Deposit!]! @derivedFrom(field: "pool")
  withdraws: [Withdraw!]! @derivedFrom(field: "pool")
  swaps: [Swap!]! @derivedFrom(field: "pool")
}

##################################
##### Transaction-Level Data #####
##################################

# An event is any user action that occurs in a protocol. Generally, they are Ethereum events
# emitted by a function in the smart contracts, stored in transaction receipts as event logs.
# However, some user actions of interest are function calls that don't emit events. For example,
# the deposit and withdraw functions in Yearn do not emit any events. In our subgraphs, we still
# store them as events, although they are not technically Ethereum events emitted by smart
# contracts.

interface Event {
  id: ID!
  hash: String!
  logIndex: Int!
  protocol: DexAmmProtocol!
  to: String!
  from: String!
  blockNumber: BigInt!
  timestamp: BigInt!
}

type Deposit implements Event @entity {
  id: ID!
  hash: String!
  logIndex: Int!
  protocol: DexAmmProtocol!
  to: String!
  from: String!
  blockNumber: BigInt!
  timestamp: BigInt!
  inputTokens: [Token!]!
  outputTokens: Token!
  inputTokenAmounts: [BigInt!]!
  outputTokenAmount: BigInt!
  amountUSD: BigDecimal!
  ##### DexAmm-Specific #####
  pool: LiquidityPool!
}

type Withdraw implements Event @entity {
  id: ID!
  hash: String!
  logIndex: Int!
  protocol: DexAmmProtocol!
  to: String!
  from: String!
  blockNumber: BigInt!
  timestamp: BigInt!
  inputTokens: [Token!]!
  outputTokens: Token!
  inputTokenAmounts: [BigInt!]!
  outputTokenAmount: BigInt!
  amountUSD: BigDecimal!
  ##### DexAmm-Specific #####
  pool: LiquidityPool!
}

type Swap implements Event @entity {
  id: ID!
  hash: String!
  logIndex: Int!
  protocol: DexAmmProtocol!
  to: String!
  from: String!
  blockNumber: BigInt!
  timestamp: BigInt!
  tokenIn: Token!
  amountIn: BigInt!
  amountInUSD: BigDecimal!
  tokenOut: Token!
  amountOut: BigInt!
  amountOutUSD: BigDecimal!
  ##### DexAmm-Specific #####
  pool: LiquidityPool!
}

###########################
##### Helper Entities #####
###########################

# Helper entities are additional entities created to help with mapping.
# They are usually used to store internal states that would simplify
# the mapping logic. All helper entities should be prefixed with an
# underscore to differentiate them from the common schema.

# An account is a unique Ethereum address
type _Account @entity {
  " Address of the account "
  id: ID!
}

type _DailyActiveAccount @entity {
  " { Days since Unix epoch }-{ Address of the account } "
  id: ID!
}
